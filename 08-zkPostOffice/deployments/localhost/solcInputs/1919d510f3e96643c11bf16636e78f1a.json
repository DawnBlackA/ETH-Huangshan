{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libraries/ZKVerifierLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title ZKVerifierLib\r\n * @dev 零知识证明验证器库 - 集成Groth16验证系统\r\n * 使用password_verifier_simple.circom电路的真实验证密钥\r\n */\r\nlibrary ZKVerifierLib {\r\n    // ============== 数据结构 ==============\r\n\r\n    struct G1Point {\r\n        uint256 X;\r\n        uint256 Y;\r\n    }\r\n\r\n    struct G2Point {\r\n        uint256[2] X;\r\n        uint256[2] Y;\r\n    }\r\n\r\n    struct VerifyingKey {\r\n        G1Point alpha;\r\n        G2Point beta;\r\n        G2Point gamma;\r\n        G2Point delta;\r\n        G1Point[] gamma_abc;\r\n    }\r\n\r\n    struct Proof {\r\n        G1Point a;\r\n        G2Point b;\r\n        G1Point c;\r\n    }\r\n\r\n    // ============== 常数定义 ==============\r\n\r\n    // BN254曲线参数\r\n    uint256 constant FIELD_ORDER = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n    uint256 constant GEN_ORDER = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    // ============== 核心验证函数 ==============\r\n\r\n    /**\r\n     * @dev 获取真实的验证密钥（从password_verifier_simple电路生成）\r\n     */\r\n    function getRealVerifyingKey() internal pure returns (VerifyingKey memory vk) {\r\n        vk.alpha = G1Point(\r\n            2911067560956003489024943952335866471458629375826063170287557710018668738899, \r\n            14360464997856870042143902358097371582005132321762034022657109592749434245855\r\n        );\r\n        \r\n        vk.beta = G2Point({\r\n            X: [14932019986030422231521332474610432755711424070676691052314672389853988775562, 17399300290253197908307003165906955655728672955044044292813453559610461543689],\r\n            Y: [16188676036473203583905616850046327769708148331282701067321814152195211630088, 13726202729215909871138606722447882177488428257301352103612535719341999544299]\r\n        });\r\n        \r\n        vk.gamma = G2Point({\r\n            X: [11559732032986387107991004021392285783925812861821192530917403151452391805634, 10857046999023057135944570762232829481370756359578518086990519993285655852781],\r\n            Y: [4082367875863433681332203403145435568316851327593401208105741076214120093531, 8495653923123431417604973247489272438418190587263600148770280649306958101930]\r\n        });\r\n        \r\n        vk.delta = G2Point({\r\n            X: [6609936434416628110144442466813297421507170160492660429222852076884527310595, 11386068247985606029843093792228852503754062072088166300548215760807129923183],\r\n            Y: [15599912747120464301362628977793487469111185726449624117889074198632005476946, 3514778236844765523501790508201526254146673474375309527416201555705026385809]\r\n        });\r\n        \r\n        // IC数组 - password_verifier_simple电路支持2个公共输入\r\n        vk.gamma_abc = new G1Point[](3);\r\n        vk.gamma_abc[0] = G1Point(8026766644554531811303835052584886422458802620875668938808803818966212361472, 3293192426388331798003929825159729798203531748039231826070769286205912394749);\r\n        vk.gamma_abc[1] = G1Point(8398671413336031077775046020474579270264639489357841383398068518042064423128, 7320082548207887374868921357620286676045778256402382395970652587786416541090);\r\n        vk.gamma_abc[2] = G1Point(1113738509148725233099375379449193372256493800058638881230893861021797139963, 1696771457979343777264130696330266341754480517388895127181476203698226717378);\r\n    }\r\n\r\n    /**\r\n     * @dev 验证Groth16零知识证明\r\n     * @param proof 证明数据 [a.x, a.y, b.x[0], b.x[1], b.y[0], b.y[1], c.x, c.y]\r\n     * @param input 公共输入数组\r\n     * @return 验证结果\r\n     */\r\n    function verifyProof(uint256[8] memory proof, uint256[] memory input) internal view returns (bool) {\r\n        VerifyingKey memory vk = getRealVerifyingKey();\r\n        \r\n        // 检查公共输入数量\r\n        if (input.length + 1 != vk.gamma_abc.length) {\r\n            return false;\r\n        }\r\n\r\n        // 解析证明\r\n        Proof memory p = Proof({ \r\n            a: G1Point(proof[0], proof[1]), \r\n            b: G2Point([proof[2], proof[3]], [proof[4], proof[5]]), \r\n            c: G1Point(proof[6], proof[7]) \r\n        });\r\n\r\n        // 计算 vk_x = gamma_abc[0] + sum(input[i] * gamma_abc[i+1])\r\n        G1Point memory vk_x = vk.gamma_abc[0];\r\n        for (uint256 i = 0; i < input.length; i++) {\r\n            vk_x = _ecAdd(vk_x, _ecMul(vk.gamma_abc[i + 1], input[i]));\r\n        }\r\n\r\n        // Groth16验证等式: e(-A,B) * e(alpha,beta) * e(vk_x,gamma) * e(C,delta) = 1\r\n        return _pairing4(\r\n            _ecNegate(p.a), p.b,\r\n            vk.alpha, vk.beta,\r\n            vk_x, vk.gamma,\r\n            p.c, vk.delta\r\n        );\r\n    }\r\n\r\n    // ============== 内部椭圆曲线运算 ==============\r\n\r\n    function _ecAdd(G1Point memory p1, G1Point memory p2) private view returns (G1Point memory r) {\r\n        uint256[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\r\n        }\r\n        require(success, \"EC addition failed\");\r\n    }\r\n\r\n    function _ecMul(G1Point memory p, uint256 s) private view returns (G1Point memory r) {\r\n        uint256[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\r\n        }\r\n        require(success, \"EC multiplication failed\");\r\n    }\r\n\r\n    function _ecNegate(G1Point memory p) private pure returns (G1Point memory) {\r\n        if (p.X == 0 && p.Y == 0) return G1Point(0, 0);\r\n        return G1Point(p.X, FIELD_ORDER - (p.Y % FIELD_ORDER));\r\n    }\r\n\r\n    function _pairing4(\r\n        G1Point memory a1, G2Point memory a2,\r\n        G1Point memory b1, G2Point memory b2,\r\n        G1Point memory c1, G2Point memory c2,\r\n        G1Point memory d1, G2Point memory d2\r\n    ) private view returns (bool) {\r\n        uint256[24] memory input;\r\n        \r\n        // 第一个配对\r\n        input[0] = a1.X;\r\n        input[1] = a1.Y;\r\n        input[2] = a2.X[0];\r\n        input[3] = a2.X[1];\r\n        input[4] = a2.Y[0];\r\n        input[5] = a2.Y[1];\r\n        \r\n        // 第二个配对\r\n        input[6] = b1.X;\r\n        input[7] = b1.Y;\r\n        input[8] = b2.X[0];\r\n        input[9] = b2.X[1];\r\n        input[10] = b2.Y[0];\r\n        input[11] = b2.Y[1];\r\n        \r\n        // 第三个配对\r\n        input[12] = c1.X;\r\n        input[13] = c1.Y;\r\n        input[14] = c2.X[0];\r\n        input[15] = c2.X[1];\r\n        input[16] = c2.Y[0];\r\n        input[17] = c2.Y[1];\r\n        \r\n        // 第四个配对\r\n        input[18] = d1.X;\r\n        input[19] = d1.Y;\r\n        input[20] = d2.X[0];\r\n        input[21] = d2.X[1];\r\n        input[22] = d2.Y[0];\r\n        input[23] = d2.Y[1];\r\n\r\n        uint256[1] memory out;\r\n        bool success;\r\n        \r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, input, 768, out, 32)\r\n        }\r\n        \r\n        require(success, \"Pairing check failed\");\r\n        return out[0] != 0;\r\n    }\r\n}\r\n"
    },
    "contracts/ZKVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\r\n\r\nimport \"./libraries/ZKVerifierLib.sol\";\r\n\r\n/**\r\n * @title ZKVault\r\n * @dev 使用零知识证明保护密码的信件保险库合约\r\n * 用户可以存储信件和附件，使用ZK证明验证身份而无需暴露密码明文\r\n */\r\ncontract ZKVault is OwnableUpgradeable, ERC721Holder, ERC1155Holder {\r\n    using ZKVerifierLib for *;\r\n\r\n    uint8 public constant ETH_TYPE = 0;\r\n    uint8 public constant ERC20_TYPE = 1;\r\n    uint8 public constant ERC721_TYPE = 2;\r\n    uint8 public constant ERC1155_TYPE = 3;\r\n\r\n    // 事件\r\n    event SendLetter(bytes32 indexed _letterId, address indexed _sender, bytes32 _passwordHash, bytes[] _annexKeys);\r\n    event Claim(bytes32 indexed _letterId, address indexed _claimer);\r\n    event TimeoutClaim(bytes32 indexed _letterId, address indexed _sender);\r\n    event ZKProofVerified(bytes32 indexed _letterId, address indexed _claimer, bool _success);\r\n\r\n    // 附件结构\r\n    struct Annex {\r\n        uint8 _type;\r\n        address _address;\r\n        uint256 _amount;\r\n        uint256 _id;\r\n    }\r\n\r\n    // 信件结构 - 不再存储明文密码\r\n    struct Letter {\r\n        bytes32 _letterId;\r\n        address _sender;\r\n        uint256 _annexAmount;\r\n        uint256 _deadline;\r\n        string _message;\r\n        string _secretWords;\r\n        bytes32 _passwordHash; // 存储密码哈希而非明文\r\n        uint256 _nonce; // 防止重放攻击\r\n        bool _claimed; // 是否已被领取\r\n    }\r\n\r\n    // ZK验证相关结构\r\n    struct ZKProofData {\r\n        uint256[8] proof; // Groth16 证明\r\n        uint256[] publicInputs; // 公共输入：[isValid, passwordHash]\r\n    }\r\n\r\n    // 批量读取结果结构\r\n    struct LetterReadResult {\r\n        bytes32 letterId;\r\n        bool success;\r\n        string message;\r\n        string secretWords;\r\n        Annex[] annexes;\r\n    }\r\n\r\n    // 存储映射\r\n    mapping(bytes32 => Letter) private letters; // letterId => Letter\r\n    mapping(bytes32 => bytes32) private passwordHashToId; // passwordHash => letterId\r\n    mapping(bytes => Annex) private annex; // annexKey => Annex\r\n\r\n    // 错误定义\r\n    error UnauthorizedAccess();\r\n    error LetterNotExists();\r\n    error LetterAlreadyClaimed();\r\n    error LetterExpired();\r\n    error LetterNotExpired();\r\n    error InvalidProof();\r\n    error InsufficientETH();\r\n    error PasswordHashExists();\r\n\r\n    constructor() {\r\n        initialize();\r\n    }\r\n\r\n    function initialize() public initializer {\r\n        __Ownable_init();\r\n    }\r\n\r\n    // ================== write function ==================\r\n\r\n    /**\r\n     * @dev 发送信件 - 使用密码哈希而非明文，nonce由外部传入\r\n     * @param _annex 附件数组\r\n     * @param _message 信件消息\r\n     * @param _secretWords 密语\r\n     * @param _passwordHash 密码的哈希值（keccak256(password)）\r\n     * @param _deadline 截止时间\r\n     * @param _nonce 外部传入的nonce（建议使用时间戳）\r\n     */\r\n    function sendLetter(\r\n        Annex[] memory _annex,\r\n        string memory _message,\r\n        string memory _secretWords,\r\n        bytes32 _passwordHash,\r\n        uint256 _deadline,\r\n        uint256 _nonce\r\n    ) external payable returns (bytes32 _letterId) {\r\n        Letter memory _letter;\r\n        // 注释掉密码哈希重复检查，因为钱包绑定的哈希允许不同钱包使用相同密码\r\n        if (passwordHashToId[_passwordHash] != bytes32(0)) {\r\n            _letter = letters[passwordHashToId[_passwordHash]];\r\n            delete letters[_letterId];\r\n            delete passwordHashToId[_passwordHash];\r\n            _transferAnnexes(_letter, _letter._sender);\r\n            revert PasswordHashExists();\r\n        }\r\n\r\n        // 生成唯一的信件ID\r\n        _letterId = _buildId(_annex, _message, _secretWords, _passwordHash, _deadline);\r\n\r\n        bytes[] memory _keys = new bytes[](_annex.length);\r\n\r\n        // 处理附件转移\r\n        for (uint256 _i = 0; _i < _annex.length; _i++) {\r\n            _transferAnnexToVault(_annex[_i]);\r\n            bytes memory _annexKey = abi.encodePacked(_letterId, _i);\r\n            annex[_annexKey] = _annex[_i];\r\n            _keys[_i] = _annexKey;\r\n        }\r\n\r\n        // 创建信件\r\n        _letter = Letter({\r\n            _letterId: _letterId,\r\n            _sender: msg.sender,\r\n            _annexAmount: _annex.length,\r\n            _message: _message,\r\n            _secretWords: _secretWords,\r\n            _passwordHash: _passwordHash,\r\n            _deadline: _deadline,\r\n            _nonce: _nonce,\r\n            _claimed: false\r\n        });\r\n\r\n        letters[_letterId] = _letter;\r\n        passwordHashToId[_passwordHash] = _letterId;\r\n\r\n        emit SendLetter(_letterId, msg.sender, _passwordHash, _keys);\r\n    }\r\n\r\n    /**\r\n     * @dev 使用零知识证明领取信件\r\n     * @param _letterId 信件ID\r\n     * @param _zkProof ZK证明数据\r\n     */\r\n    function claimWithZKProof(bytes32 _letterId, ZKProofData memory _zkProof) external {\r\n        Letter storage _letter = letters[_letterId];\r\n        if (_letter._sender == address(0)) revert LetterNotExists();\r\n        if (_letter._claimed) revert LetterAlreadyClaimed();\r\n        if (_letter._deadline <= block.timestamp) revert LetterExpired();\r\n\r\n        // 验证ZK证明\r\n        // 公共输入应该是: [isValid, passwordHash]\r\n        // 私密输入是: password（在电路中验证 password^2 == passwordHash）\r\n        bool _proofValid = _verifyZKProof(_letter, _zkProof);\r\n\r\n        emit ZKProofVerified(_letterId, msg.sender, _proofValid);\r\n\r\n        if (!_proofValid) revert InvalidProof();\r\n\r\n        // 标记为已领取\r\n        _letter._claimed = true;\r\n        delete passwordHashToId[_letter._passwordHash];\r\n\r\n        // 转移所有附件给领取者\r\n        _transferAnnexes(_letter, msg.sender);\r\n\r\n        emit Claim(_letterId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev 超时后发送者可以收回信件\r\n     */\r\n    function timeoutClaim(bytes32 _letterId) external {\r\n        Letter storage _letter = letters[_letterId];\r\n        if (_letter._sender == address(0)) revert LetterNotExists();\r\n        if (_letter._sender != msg.sender) revert UnauthorizedAccess();\r\n        if (_letter._deadline > block.timestamp) revert LetterNotExpired();\r\n        if (_letter._claimed) revert LetterAlreadyClaimed();\r\n\r\n        // 标记为已领取（防止重复领取）\r\n        _letter._claimed = true;\r\n        delete passwordHashToId[_letter._passwordHash];\r\n        delete letters[_letterId];\r\n\r\n        // 退还所有附件给发送者\r\n        _transferAnnexes(_letter, _letter._sender);\r\n\r\n        emit TimeoutClaim(_letterId, msg.sender);\r\n    }\r\n\r\n    // ================== view function ==================\r\n\r\n    /**\r\n     * @dev 获取信件的公开参数\r\n     */\r\n    function letterPublicParams(bytes32 _letterId) external view returns (address _sender, string memory _message, uint256 _deadline, bytes32 _passwordHash, uint256 _nonce, bool _claimed) {\r\n        Letter memory _letter = letters[_letterId];\r\n        return (_letter._sender, _letter._message, _letter._deadline, _letter._passwordHash, _letter._nonce, _letter._claimed);\r\n    }\r\n\r\n    /**\r\n     * @dev 通过密码哈希查询信件ID\r\n     */\r\n    function getLetterIdByPasswordHash(bytes32 _passwordHash) external view returns (bytes32) {\r\n        return passwordHashToId[_passwordHash];\r\n    }\r\n\r\n    /**\r\n     * @dev 获取信件的附件信息（需要知道letterId）\r\n     */\r\n    function getLetterAnnexes(bytes32 _letterId) external view returns (Annex[] memory _annexes) {\r\n        Letter memory _letter = letters[_letterId];\r\n        if (_letter._sender == address(0)) return _annexes;\r\n\r\n        _annexes = new Annex[](_letter._annexAmount);\r\n        for (uint256 _i = 0; _i < _letter._annexAmount; _i++) {\r\n            _annexes[_i] = annex[abi.encodePacked(_letterId, _i)];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev 测试函数：直接验证ZK证明（用于调试对比）\r\n     */\r\n    function testVerifyProof(uint256[8] memory proof, uint256[] memory input) external view returns (bool) {\r\n        return ZKVerifierLib.verifyProof(proof, input);\r\n    }\r\n\r\n    /**\r\n     * @dev 通过ZK证明读取信件的加密信息\r\n     * @param _letterId 信件ID\r\n     * @param _zkProof ZK证明数据\r\n     * @return _success 验证是否成功\r\n     * @return _secretWords 密语（仅在验证成功时返回）\r\n     * @return _message 信件消息\r\n     * @return _annexes 附件信息\r\n     */\r\n    function readLetterWithZKProof(bytes32 _letterId, ZKProofData memory _zkProof) external view returns (bool _success, string memory _secretWords, string memory _message, Annex[] memory _annexes) {\r\n        Letter memory _letter = letters[_letterId];\r\n\r\n        // 检查信件是否存在\r\n        if (_letter._sender == address(0)) {\r\n            return (false, \"\", \"\", new Annex[](0));\r\n        }\r\n\r\n        // 验证ZK证明\r\n        bool _proofValid = _verifyZKProof(_letter, _zkProof);\r\n\r\n        if (!_proofValid) {\r\n            return (false, \"\", \"\", new Annex[](0));\r\n        }\r\n\r\n        // 验证成功，返回加密信息\r\n        _annexes = new Annex[](_letter._annexAmount);\r\n        for (uint256 _i = 0; _i < _letter._annexAmount; _i++) {\r\n            _annexes[_i] = annex[abi.encodePacked(_letterId, _i)];\r\n        }\r\n\r\n        return (true, _letter._secretWords, _letter._message, _annexes);\r\n    }\r\n\r\n    /**\r\n     * @dev 通过ZK证明读取信件的完整信息（包括敏感信息）\r\n     * @param _letterId 信件ID\r\n     * @param _zkProof ZK证明数据\r\n     * @return _success 验证是否成功\r\n     * @return _letter 完整的信件信息（如果验证成功）\r\n     */\r\n    function getLetterDetailWithZKProof(bytes32 _letterId, ZKProofData memory _zkProof) external view returns (bool _success, Letter memory _letter) {\r\n        _letter = letters[_letterId];\r\n\r\n        // 检查信件是否存在\r\n        if (_letter._sender == address(0)) {\r\n            return (false, _letter);\r\n        }\r\n\r\n        // 验证ZK证明\r\n        bool _proofValid = _verifyZKProof(_letter, _zkProof);\r\n\r\n        if (!_proofValid) {\r\n            // 验证失败，清空敏感信息\r\n            _letter._secretWords = \"\";\r\n            _letter._message = \"\";\r\n            return (false, _letter);\r\n        }\r\n\r\n        // 验证成功，返回完整信件信息\r\n        return (true, _letter);\r\n    }\r\n\r\n    // ================== 内部函数 ==================\r\n\r\n    /**\r\n     * @dev 验证零知识证明\r\n     * @param _letter 信件信息\r\n     * @param _zkProof ZK证明数据\r\n     */\r\n    function _verifyZKProof(Letter memory _letter, ZKProofData memory _zkProof) internal view returns (bool) {\r\n        // 实际的公共输入顺序：[isValid, passwordHash]\r\n        // 验证公共输入数量\r\n        if (_zkProof.publicInputs.length != 2) {\r\n            return false;\r\n        }\r\n\r\n        // 验证第一个公共输入（isValid）应该为1\r\n        if (_zkProof.publicInputs[0] != 1) {\r\n            return false;\r\n        }\r\n\r\n        // 关键验证：验证证明中的passwordHash是否与信件的passwordHash匹配\r\n        // 注意：两者都应该使用相同的哈希方法（password^2 或 keccak256(password)）\r\n        uint256 letterPasswordHash = uint256(_letter._passwordHash);\r\n        if (_zkProof.publicInputs[1] != letterPasswordHash) {\r\n            return false;\r\n        }\r\n\r\n        // 使用ZKVerifierLib验证证明\r\n        return ZKVerifierLib.verifyProof(_zkProof.proof, _zkProof.publicInputs);\r\n    }\r\n\r\n    /**\r\n     * @dev 将附件转移到保险库\r\n     */\r\n    function _transferAnnexToVault(Annex memory _annex) internal {\r\n        if (_annex._type == ETH_TYPE) {\r\n            if (msg.value < _annex._amount) revert InsufficientETH();\r\n        } else if (_annex._type == ERC20_TYPE) {\r\n            IERC20(_annex._address).transferFrom(msg.sender, address(this), _annex._amount);\r\n        } else if (_annex._type == ERC721_TYPE) {\r\n            IERC721(_annex._address).transferFrom(msg.sender, address(this), _annex._id);\r\n        } else if (_annex._type == ERC1155_TYPE) {\r\n            IERC1155(_annex._address).safeTransferFrom(msg.sender, address(this), _annex._id, _annex._amount, new bytes(0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev 将附件转移给领取者\r\n     */\r\n    function _transferAnnexes(Letter memory _letter, address _recipient) internal {\r\n        for (uint256 _i = 0; _i < _letter._annexAmount; _i++) {\r\n            bytes memory _annexId = abi.encodePacked(_letter._letterId, _i);\r\n            Annex memory _annex = annex[_annexId];\r\n\r\n            if (_annex._type == ETH_TYPE) {\r\n                payable(_recipient).transfer(_annex._amount);\r\n            } else if (_annex._type == ERC20_TYPE) {\r\n                IERC20(_annex._address).transfer(_recipient, _annex._amount);\r\n            } else if (_annex._type == ERC721_TYPE) {\r\n                IERC721(_annex._address).safeTransferFrom(address(this), _recipient, _annex._id);\r\n            } else if (_annex._type == ERC1155_TYPE) {\r\n                IERC1155(_annex._address).safeTransferFrom(address(this), _recipient, _annex._id, _annex._amount, new bytes(0));\r\n            }\r\n\r\n            delete annex[_annexId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev 构建信件ID - 简化版本，减少堆栈使用\r\n     */\r\n    function _buildId(Annex[] memory _annex, string memory _message, string memory _secretWords, bytes32 _passwordHash, uint256 _deadline) internal view returns (bytes32) {\r\n        bytes32 annexHash = _annex.length > 0 ? keccak256(abi.encode(_annex)) : bytes32(0);\r\n        return keccak256(abi.encodePacked(annexHash, _message, _secretWords, _passwordHash, _deadline, msg.sender, block.timestamp, block.number));\r\n    }\r\n\r\n    /**\r\n     * @dev 接收ETH\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}